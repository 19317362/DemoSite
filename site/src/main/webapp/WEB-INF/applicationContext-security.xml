<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p"
    xmlns:sec="http://www.springframework.org/schema/security"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:util="http://www.springframework.org/schema/util"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
    	http://www.springframework.org/schema/beans
    	http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
    	http://www.springframework.org/schema/context
    	http://www.springframework.org/schema/context/spring-context-3.1.xsd
    	http://www.springframework.org/schema/security
    	http://www.springframework.org/schema/security/spring-security-3.1.xsd
    	http://www.springframework.org/schema/util
    	http://www.springframework.org/schema/util/spring-util-3.1.xsd">

    <context:component-scan base-package="org.broadleafcommerce.common.web.security"/>
    <context:component-scan base-package="org.broadleafcommerce.profile.web.core.security"/>
    <context:component-scan base-package="org.broadleafcommerce.core.web.order.security"/>

    <!-- We are customizing the spring security filters and have different behavior for REST calls
         versus standard web requests.   For this reason, we are not using namespace configuration
         and instead are opting to define the entire filter chain. -->
	<bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
		<sec:filter-chain-map request-matcher="ant">
			<!--  Any resources that do not require a security context should be included here. -->
			<sec:filter-chain pattern="/css/**" filters="none" />
			<sec:filter-chain pattern="/images/**" filters="none" />
			<sec:filter-chain pattern="/js/**" filters="none" />       
                	
           <!--  REST APIs are Stateless.   The following implementation works well for clients
                 who are in the same data center.    For others, additional security considerations will
                 need to be made to determine whether or not the caller has rights to invoke calls on 
                 behalf of the passed in customer id.   -->     	
           <sec:filter-chain pattern="/api/**" 
                filters="                    
                    blRequestWrapperFilter,
                    blRestCustomerStateFilter"/>
                    
            <!-- All other web requests need to be served through the default filter chain.
                 Each of the filters is documented below.  -->     
			<sec:filter-chain pattern="/**"
				filters="
                	blSecurityContextPersistenceFilterWithAllowSessionCreationTrue,
                	blLogoutFilter,
                	blAuthenticationProcessingFilter,
                	blRequestWrapperFilter,
                	blRememberMeAuthenticationFilter,
                	blCustomerStateFilter,
                	blCartStateFilter,
                	blExceptionTranslationFilter,
                	blFilterSecurityInterceptor" />                    
		</sec:filter-chain-map>
	</bean>




    <!--
      FILTER DEFINITIONS  
    -->
    <!--  Allow the security filter to create a session. -->
	<bean id="blSecurityContextPersistenceFilterWithAllowSessionCreationTrue"
		class="org.springframework.security.web.context.SecurityContextPersistenceFilter">
        <constructor-arg>
            <bean class='org.springframework.security.web.context.HttpSessionSecurityContextRepository'>
                <property name='allowSessionCreation' value='true' />
            </bean>
        </constructor-arg>
	</bean>

    <!--  Wraps the HttpServletRequest so that request.isUserInRole and request.getUserPrincipal utilize the
          Spring Security Authentication. -->
	<bean id="blRequestWrapperFilter"
		class="org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter" />
    
    <!--  Used for REST api calls.   This just takes in the passed in customerId and uses it to establish the customer.
          Additional considerations MUST be made for implementations that are allowing external access to APIs.  -->
    <bean id="blRestCustomerStateFilter"
          class="org.broadleafcommerce.profile.web.core.security.RestApiCustomerStateFilter"/>

    <!--  Supports cookies that only are served over http -->
	<bean id="blRememberMeServices"
		class="org.broadleafcommerce.common.security.EnhancedTokenBasedRememberMeServices">
        <constructor-arg value="SPRING_SECURITY_REMEMBER_ME_COOKIE"/>
        <constructor-arg ref="blUserDetailsService"/>
	</bean>

	<!--  Use the broadleaf authentication manager and remember me services with this filter. -->
	<bean id="blRememberMeAuthenticationFilter"
		class="org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter">
        <constructor-arg ref="blAuthenticationManager"/>
        <constructor-arg ref="blRememberMeServices"/>
	</bean>

    <!--  Redirects the user to the logoutSuccessUrl, -->
	<bean id="blLogoutFilter"
		class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<constructor-arg>
			<bean
				class="org.springframework.security.web.authentication.logout.SimpleUrlLogoutSuccessHandler" />
		</constructor-arg>
		<constructor-arg>
			<list>
				<ref local="blRememberMeServices" />
				<bean
					class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler" />
			</list>
		</constructor-arg>
	</bean>

    <!--  Sets the RememberMe Cookie name -->
	<bean id="blRememberMeAuthenticationProvider"
		class="org.springframework.security.authentication.RememberMeAuthenticationProvider">
        <constructor-arg value="SPRING_SECURITY_REMEMBER_ME_COOKIE"/>
	</bean>

    <!--  User details service that authenticates using customer data in the database. -->
	<sec:jdbc-user-service data-source-ref="webDS"
		id="blUserDetailsService"
		users-by-username-query="SELECT USER_NAME,PASSWORD,TRUE FROM BLC_CUSTOMER WHERE USER_NAME=?"
		authorities-by-username-query="SELECT c.USER_NAME,r.ROLE_NAME from BLC_CUSTOMER c 
	                                      JOIN BLC_CUSTOMER_ROLE cr ON c.CUSTOMER_ID = cr.CUSTOMER_ID 
	                                      JOIN BLC_ROLE r ON cr.ROLE_ID = r.ROLE_ID 
	                                      WHERE USER_NAME=?" />

    <!-- Sets the login failure URL -->
	<bean id="broadleafAuthenticationFailureHandler"
		class="org.broadleafcommerce.common.security.BroadleafAuthenticationFailureHandler">
		<constructor-arg value="/login?error=true" />
		<property name="redirectStrategy" ref="blAuthenticationFailureRedirectStrategy" />
	</bean>

    <!-- Sets the login success URL -->
	<bean id="broadleafAuthenticationSuccessHandler"
		class="org.broadleafcommerce.core.web.order.security.BroadleafAuthenticationSuccessHandler">
		<property name="redirectStrategy" ref="blAuthenticationSuccessRedirectStrategy" />
		<property name="defaultTargetUrl" value="/" />
		<property name="alwaysUseDefaultTargetUrl" value="true" />
	</bean>
  
     <!--  Sets up the filter that receives the login post.    -->
	<bean id="blAuthenticationProcessingFilter"
		class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter">
		<property name="authenticationManager" ref="blAuthenticationManager" />
		<property name="authenticationFailureHandler" ref="broadleafAuthenticationFailureHandler" />
		<property name="authenticationSuccessHandler" ref="broadleafAuthenticationSuccessHandler" />
		<property name="filterProcessesUrl" value="/login_post.htm" />
        <property name="rememberMeServices" ref="blRememberMeServices"/>
	</bean>

	<!-- URL a user goes to when they were unable to hit a page that requires access. -->
	<bean id="blExceptionTranslationFilter"
		class="org.springframework.security.web.access.ExceptionTranslationFilter">
		<property name="authenticationEntryPoint">
			<bean
				class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
				<property name="loginFormUrl" value="/login" />
				<property name="forceHttps" value="false" />
				<property name="portMapper">
					<bean class="org.springframework.security.web.PortMapperImpl">
						<property name="portMappings">
							<map>
								<entry key="8080">
									<value>8443</value>
								</entry>
							</map>
						</property>
					</bean>
				</property>
			</bean>
		</property>
	</bean>

     <!--  Secure pages or configure HTTP/HTTPS access here. -->
	<bean id="blFilterSecurityInterceptor"
		class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
		<property name="accessDecisionManager">
			<bean class="org.springframework.security.access.vote.UnanimousBased">
				<property name="decisionVoters">
					<list>
						<bean class="org.springframework.security.access.vote.RoleVoter" />
					</list>
				</property>
			</bean>
		</property>
		<property name="authenticationManager" ref="blAuthenticationManager" />
		<property name="securityMetadataSource">
			<sec:filter-security-metadata-source>
<!-- 				<sec:intercept-url pattern="/login" access="ROLE_USER"  /> -->
<!-- 				<sec:intercept-url pattern="/register" access="ROLE_USER"  /> -->
				<sec:intercept-url pattern="/account/**" access="ROLE_USER"  />
			</sec:filter-security-metadata-source>
		</property>
	</bean>
	
	<!--  Setup a filter that will check method level security for methods annotated with the rolePrefix.   -->
	<bean id="blAccessDecisionManager" class="org.springframework.security.access.vote.UnanimousBased">
		<property name="decisionVoters">
			<list>
				<bean class="org.springframework.security.access.vote.RoleVoter">
					<property name="rolePrefix" value="PERMISSION_" />
				</bean>
			</list>
		</property>
	</bean>

	<!--  Enforces method annotation security.   -->
	<sec:global-method-security access-decision-manager-ref="blAccessDecisionManager" secured-annotations="enabled" />
		
	<!--  The BLC Authentication manager.   -->
	<sec:authentication-manager alias="blAuthenticationManager">
		<sec:authentication-provider
			user-service-ref="blUserDetailsService">
			<sec:password-encoder ref="blPasswordEncoder" />
		</sec:authentication-provider>
		<sec:authentication-provider ref="blRememberMeAuthenticationProvider" />
	</sec:authentication-manager>
</beans>