<?xml version="1.0" encoding="UTF-8" ?>
<schema name="example" version="1.5">
	<fields>
		<dynamicField name="*_i" type="int" indexed="true" stored="true" />
		<dynamicField name="*_is" type="int" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_s" type="string" indexed="true" stored="true" />
		<dynamicField name="*_ss" type="string" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_l" type="long" indexed="true" stored="true" />
		<dynamicField name="*_ls" type="long" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_t" type="text_general" indexed="true" stored="true" />
		<dynamicField name="*_txt" type="text_general" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_b" type="boolean" indexed="true" stored="true" />
		<dynamicField name="*_bs" type="boolean" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_f" type="float" indexed="true" stored="true" />
		<dynamicField name="*_fs" type="float" indexed="true" stored="true" multiValued="true" />
		<dynamicField name="*_d" type="double" indexed="true" stored="true" />
		<dynamicField name="*_ds" type="double" indexed="true" stored="true" multiValued="true" />

		<!-- Type used to index the lat and lon components for the "location" FieldType -->
		<dynamicField name="*_coordinate" type="tdouble" indexed="true" stored="false" />

		<dynamicField name="*_dt" type="date" indexed="true" stored="true" />
		<dynamicField name="*_dts" type="date" indexed="true" stored="true" multiValued="true" />

		<!-- some trie-coded dynamic fields for faster range queries -->
		<dynamicField name="*_ti" type="tint" indexed="true" stored="true" />
		<dynamicField name="*_tl" type="tlong" indexed="true" stored="true" />
		<dynamicField name="*_tf" type="tfloat" indexed="true" stored="true" />
		<dynamicField name="*_td" type="tdouble" indexed="true" stored="true" />
		<dynamicField name="*_tdt" type="tdate" indexed="true" stored="true" />

		<dynamicField name="*_pi" type="pint" indexed="true" stored="true" />

		<dynamicField name="ignored_*" type="ignored" multiValued="true" />
		<dynamicField name="attr_*" type="text_general" indexed="true" stored="true" multiValued="true" />

		<dynamicField name="random_*" type="random" />
	</fields>

	<types>
		<!-- The StrField type is not analyzed, but indexed/stored verbatim. -->
		<fieldType name="string" class="solr.StrField" sortMissingLast="true" />

		<!-- boolean type: "true" or "false" -->
		<fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" />

		<!-- Default numeric field types. For faster range queries, consider the 
			tint/tfloat/tlong/tdouble types. -->
		<fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0" />
		<fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0" />
		<fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0" />
		<fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0" />

		<!-- Numeric field types that index each value at various levels of precision 
			to accelerate range queries when the number of values between the range endpoints 
			is large. See the javadoc for NumericRangeQuery for internal implementation 
			details. Smaller precisionStep values (specified in bits) will lead to more 
			tokens indexed per value, slightly larger index size, and faster range queries. 
			A precisionStep of 0 disables indexing at different precision levels. -->
		<fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0" />
		<fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0" />
		<fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0" />
		<fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0" />

		<!-- The format for this date field is of the form 1995-12-31T23:59:59Z, 
			and is a more restricted form of the canonical representation of dateTime 
			http://www.w3.org/TR/xmlschema-2/#dateTime The trailing "Z" designates UTC 
			time and is mandatory. Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z 
			All other components are mandatory. Expressions can also be used to denote 
			calculations that should be performed relative to "NOW" to determine the 
			value, ie... NOW/HOUR ... Round to the start of the current hour NOW-1DAY 
			... Exactly 1 day prior to now NOW/DAY+6MONTHS+3DAYS ... 6 months and 3 days 
			in the future from the start of the current day Consult the DateField javadocs 
			for more information. Note: For faster range queries, consider the tdate 
			type -->
		<fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0" />

		<!-- A Trie based date field for faster date range queries and date faceting. -->
		<fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0" />

		<!--Binary data type. The data should be sent/retrieved in as Base64 encoded 
			Strings -->
		<fieldtype name="binary" class="solr.BinaryField" />

		<!-- Note: These should only be used for compatibility with existing indexes 
			(created with lucene or older Solr versions). Use Trie based fields instead. 
			As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last Plain 
			numeric field types that store and index the text value verbatim (and hence 
			don't correctly support range queries, since the lexicographic ordering isn't 
			equal to the numeric ordering) -->
		<fieldType name="pint" class="solr.IntField" />
		<fieldType name="plong" class="solr.LongField" />
		<fieldType name="pfloat" class="solr.FloatField" />
		<fieldType name="pdouble" class="solr.DoubleField" />
		<fieldType name="pdate" class="solr.DateField" sortMissingLast="true" />

		<!-- The "RandomSortField" is not used to store or search any data. You 
			can declare fields of this type it in your schema to generate pseudo-random 
			orderings of your docs for sorting or function purposes. The ordering is 
			generated based on the field name and the version of the index. As long as 
			the index version remains unchanged, and the same field name is reused, the 
			ordering of the docs will be consistent. If you want different psuedo-random 
			orderings of documents, for the same version of the index, use a dynamicField 
			and change the field name in the request. -->
		<fieldType name="random" class="solr.RandomSortField" indexed="true" />

		<!-- A text field that only splits on whitespace for exact matching of 
			words -->
		<fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
			<analyzer>
				<tokenizer class="solr.WhitespaceTokenizerFactory" />
			</analyzer>
		</fieldType>

		<!-- A general text field that has reasonable, generic cross-language defaults: 
			it tokenizes with StandardTokenizer and down cases. -->
		<fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<filter class="solr.LowerCaseFilterFactory" />
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<filter class="solr.LowerCaseFilterFactory" />
			</analyzer>
		</fieldType>

		<!-- since fields of this type are by default not stored or indexed, any 
			data added to them will be ignored outright. -->
		<fieldtype name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
	</types>
</schema>